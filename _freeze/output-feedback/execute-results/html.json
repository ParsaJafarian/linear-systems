{
  "hash": "b8cfffd6cae2e990fb2b008f840482b5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: State observers and output feedback\n\nexecute:\n  echo: false\n  freeze: true\n  cache: true\n---\n\n## State observer\n\nSo far, we have assumed that the controller has access to the state of the system. In many systems, it is either too expensive or physically impossible to place enough sensors to observe all the components of the state. In such cases, one option is to estimate the state from the inputs and outputs of the system and use the estimated state to chose the control input. The system which generates a state estimate from inputs and outputs is called an **observer**.\n\nAn estimate $\\hat x(t)$ of the state $x(t)$ should have two properties:\n\n- It should be asymptotitcally consistent, i.e., $\\lim_{t \\to ∞} \\NORM{x(t) - \\hat x(t)} = 0$.\n- We should be able to control the rate of convergence.\n\nWe state with a naive observer to show that it is possible to obtain asymptotically consistent estimators. We then consider how to modify the naive observer to be able to to control the rate of convergence. \n\n\n\n### A naive observer\n\nThe main idea of building an observer is to start with a (physical or digital) replica of the original system, provide it the same inputs as the original system, and measure the internal state of the replica. In particular, we start with an initial guess $\\hat x(0)$ and then update the estimate according to\n$$ \n\\dot {\\hat x}(t) = A \\hat x(t) + B u(t).\n$$\n\nA feature of this observer is that if our initial guess $\\hat x(0)$ is equal to the true initial conditions of the system then $\\hat x(t) = x(t)$ for all $t$. If the initial guess is wrong, then there is an error $e(t) = x(t) - \\hat x(t)$ in measuring the state of the system. The evolution of the error is given by: $e(0) = x(0) - \\hat x(0)$ and \n$$\n  \\dot e(t) = \\dot x(t) - \\dot {\\hat x}(t) = A e(t).\n$$\nThis is a vector linear differential equation. Hence,\n$$\n  e(t) = \\exp(At) e(0).\n$$\nThus, if $A$ is internally stable (i.e., all the eigenvalues of $A$ lie in the OLHP), then the error $e(t)$ will converge to zero. However, we have no ability to influence the rate of convergence (which depends on the eigenvalues of $A$).\n\n### The Luenberger observer\n\nThe Luenberger observer is given as follows. Start with an initial guess $\\hat x(0)$ and update the estimate according to \n$$\n\\dot {\\hat x}(t) = A \\hat x(t) + B u(t) + L( y(t) - C \\hat x(t))\n$$\nwhere $L = \\MATRIX{ \\ell_0 & \\cdots & \\ell_{n-1}}^\\TRANS$ is called the **observer gain**.\n\nIn this case, the error $e(t) = x(t) - \\hat x(t)$ evolves as follows. The initial state $e(0) = x(0) - \\hat x(0)$ and \n$$\n\\dot e(t) = \\dot x(t) - \\dot {\\hat x}(t) = (A - LC) e(t).\n$$\nThis is a vector linear differential equation.Hence,\n$$\n  e(t) = \\exp( (A-LC)t) e(0).\n$$\nThus, if $A - LC$ is stable, then the error will converge to zero with a rate that is determined by the eigenvalues of $A - LC$. \n\nThus, designing an observer gain is similar in spirit to designing a feedback gain for state feedback. In state feedback design, we are given $A$ and $B$ matrices and we want to choose a gain $K$ such that the eigenvalues of $A - BK$ take desired values; in observer desgin, we are given $A$ and $C$ matrices and we want to choose a gain $:$ such that the eigenvalues of $A - LC$ take desired values. \n\nAs was the case for state feedback, we will start with system in OCF and show that observer design for such systems can be done by simply comparing the coefficients of the characteristic polynomials of the open-loop system and the desired characteristic polynomial of $A - LC$. We then look at systems that are not in OCF and show that if the system satisfies a condition known as **observability**, we can find a transformation that converts the system to OCF, design the observer gain for the OCF representation, and translate it back to the original coordinate system. \n\n## Observer design for systems in OCF\n\nConsider a state feedback system in OCF with \n$$\nA = \\MATRIX{ 0 & \\cdots & \\cdots & 0 & - a_0 \\\\\n             1 & 0 & \\cdots & 0 & - a_1 \\\\\n             0 & 1 & \\ddots & 0 & -a_2 \\\\\n             \\vdots & \\ddots & \\ddots & \\vdots & \\vdots \\\\\n             0 & \\cdots & \\cdots & 1 & -a_{n-1} }\n,\\quad\nC = \\MATRIX{0 & \\cdots & 0 & 1}.\n$$\n\nWe want to design a Luenberger observer \n$$\n\\dot {\\hat x}(t) = A \\hat x(t) + B u(t) + L (y(t) - C \\hat x(t)),\n\\quad \\text{where } \nL = \\MATRIX{\\ell_0 \\\\ \\vdots \\\\ \\ell_{n-1}}\n$$\nsuch that the characteristic polynomial of $A - LC$ is \n$$\n\\det(sI _ A + LC) = s^n + α_{n-1} s^{n-1} + \\cdots + α_0.\n$$\n\nObserve that\n$$\nLC = \\MATRIX{\\ell_0 \\\\ \\vdots \\ell_{n-1}} \n\\MATRIX{0 & \\cdots & 0 & 1 }\n= \\MATRIX{0  & \\cdots & 0 & - \\ell_0 \\\\\n          \\vdots & \\ddots & \\vdots & \\vdots \\\\\n          0  & \\cdots & 0 & - \\ell_{n-1}}\n$$\nThus,\n$$\nA - LC = \\MATRIX{ 0 & \\cdots & \\cdots & 0 & -(a_0 + \\ell_0) \\\\\n             1 & 0 & \\cdots & 0 & - (a_1 + \\ell_1) \\\\\n             0 & 1 & \\ddots & 0 & -(a_2 + \\ell_2)\\\\\n             \\vdots & \\ddots & \\ddots & \\vdots & \\vdots \\\\\n             0 & \\cdots & \\cdots & 1 & -(a_{n-1} + \\ell_{n-1}) }\n$$\nwhich has the OCF structure. Thus,\n$$\n\\det(sI - (A - LC)) =\ns^n + (a_{n-1} + \\ell_{n-1}) s^{n-1} + \\cdots + (a_1 + \\ell_1) s + (a_0 + \\ell_0).\n$$\nObserve that each component of the observer gain matrix $L$ affects only _one_ coefficient of the characteristic polynomial. Thus, we can pick\n$$\n\\bbox[5pt,border: 1px solid]\n{L = \\MATRIX{ α_0 - a_0 \\\\ \\vdots \\\\ α_{n-1} - a_{n-1}} }\n$$\nto place the eigenvalues of $A - LC$ in the desired location.\n\n:::{#exm-OCF}\nConsider the system\n$$\nA = \\MATRIX{ 0 & -1 \\\\ 1 & -2 }\n\\quad\nC = \\MATRIX{ 0 & 1}\n$$\nDetermine the observer gain $L$ such that the eigenvalues of $A - LC$ are at $-10 \\pm 5 j$.\n:::\n\n:::{.callout-note collapse=\"true\"} \n#### Solution\n\nThe desired characteristic polynomial is \n$$ (s+10)^2 + 5^2 = s^2 + 20s + 125. $$\n\nThe current characteristic polynomial is (since the system is in OCF, we can determine it by inspection) \n$$ \\det(sI - A) = s^2 + 2s + 1. $$\n\nTherefore, the required output feedback gain is\n$$ L = \\MATRIX{ 125 - 1 \\\\ 20 - 2 } = \\MATRIX{ 124 \\\\ 18 }. $$\n\nWe verify the solution below. \n\n::: {#c24076e2 .cell execution_count=3}\n``` {.julia .cell-code}\nA = [0 -1 ; 1 -2]\nC = [0  1]\np = [-10 + 5im, -10 - 5im]\nL = place(A',C',p)'\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n2×1 adjoint(::Matrix{ComplexF64}) with eltype ComplexF64:\n 124.0 - 0.0im\n  18.0 - 0.0im\n```\n:::\n:::\n\n\n:::\n\n\n## Observer design for systems not in OCF\n\nWhen a system is not in OCF, we can still use the design of systems in OCF if there is a transformation (or change of coordinates) $x_o(t) = T^{-1} x(t)$ such that the transformed matrices $(A_o, B_o, C_o)$ are in OCF. If such a transformation can be found, then we can find the observer gain $L_o$ for the system in OCF using the method of the previous section and use[^L]\n$$\n  L = T L_o\n$$\nas the observer gain for the original system. So, as was the case for state feedback, the main question is: how do we find such a transformation?\n\n[^L]: The Luenberger observer for the new coordinate system is\n$$\n\\dot {\\hat x_o}(t) = A_o \\hat x_o(t) + B_o u(t) + L_o(y(t) - C_o \\hat x_o(t)).\n$$\nSubstituting the values of $(A_o, B_o, C_o)$, we get\n\\begin{align*}\n\\dot {\\hat x_o}(t) \n&= T^{-1} A T \\hat x_o(t) + T^{-1} B u(t) + L_o( y(t) - C T \\hat x_o(t)) \\\\\n&= T^{-1} A \\hat x(t) + T^{-1} B u(t) + L_o(y(t) - C \\hat x(t))\n\\end{align*}\nwhere we have used the fact that $\\hat x_o(t) = T \\hat x(t)$. Multiplying both sides by $T$, we get\n$$\n\\dot {\\hat x}(t) = A \\hat x(t) + B u(t) + T L_o(y(t) - C \\hat x(t)).\n$$\nHence, $L = T L_o$. \n\n### Observability matrix\n\nThe observability matrix of a state space system $(A,C)$ is defined as\n$$\n\\mathcal O_{(A,C)} = \\MATRIX{C \\\\ CA \\\\ \\vdots \\\\ C A^{n-1}}\n$$\nNow consider a change of coordinates $x_o(t) = T^{-1} x(t)$. Recall that the state space representation in the new coordinate system is\n$$\nA_o = T^{-1} A T,\n\\quad\nC_o = C T.\n$$\n\nObserve that\n\n- $A_o^2 = T^{-1} A T T^{-1} A T = T^{-1} A^2 T$\n- $A_o^3 = T^{-1} A^2 T T^{-1} A T = T^{-1} A^3 T$\n- etc.\n\nTherefore,\n\n- $C_o A_o = C T T^{-1} A T = C A T$\n- $C_o A_o^2 = C T T^{-1} A^2 T = C A^2 T$\n- etc.\n\nTherefore, the observability matrix of the system in the new coordinate system is\n\\begin{align*}\n  \\mathcal O_{(A_o, B_o)} \n  % &= \\MATRIX{ C_o \\\\ C_o A_o \\\\ \\vdots \\\\ C_o A_o^{n-1} } \\\\\n  &= \\MATRIX{ C T \\\\ C A T \\\\ \\vdots \\\\ C A^{n-1} T } \\\\\n  &= \\MATRIX{ C  \\\\ C A  \\\\ \\vdots \\\\ C A^{n-1}  } T \\\\\n  &= \\mathcal O_{(A,C)} T.\n\\end{align*}\n\nThus, we can go from SSM $(A,C)$ to SSM $(A_o,C_o)$ using the transformation\n$$\n  T = \\mathcal O_{(A,C)}^{-1} \\mathcal O_{(A_o, C_o)}\n$$\n_provided $\\mathcal O_{(A,C)}$ is invertible_ (i.e., has full rank). When that is the case, we say that the system is **observable**.\n\n### Observer design\n\nThe general observer design problem is as follows. We are given a system $(A,C)$ not in OCF and we want to design a Luenberger observer\n$$\n\\dot {\\hat x}(t) = A \\hat x(t) + B u(t) + L (y(t) - C \\hat x(t)),\n\\quad \\text{where } \nL = \\MATRIX{\\ell_0 \\\\ \\vdots \\\\ \\ell_{n-1}}\n$$\nsuch that the characteristic polynomial of $A - LC$ is \n$$\n\\det(sI _ A + LC) = s^n + α_{n-1} s^{n-1} + \\cdots + α_0.\n$$\nWe present two methods for observer design.\n\n#### Method 1: Using observability matrix {-}\n\n1. Find the observability matrix $\\mathcal O_{(A,C)}$ of the system. \n\n2. If the system is not observable, i.e., the observability matrix is not full rank (which can be tested by checking that the determinant of the observability matrix is non-zero), observer design is not possible and we quit the procedure. \n\n3. If the system is observable, find the characteristic polynomial of $A$:\n   $$\\det(s I - A) = s^n + a_{n-1} s^{n-1} + \\cdots + a_0 $$\n\n4. Using the above characteristic polynomial, write the SSM $(A_o, C_o)$ in OCF.\n\n    [Recall that the characteristic polynomial is the denominator of the transfer function]{.text-smaller}\n\n5. Compute the observability matrix $\\mathcal O(A_o, C_o)$ of the system $(A_o, B_o)$ in OCF.\n\n6. Compute the transformation\n    $$\\bbox[5pt,border: 1px solid]{\n    T = \\mathcal O_{(A, C)}^{-1} \\mathcal O_{(A_o,C_o)}\n    }$$\n\n7. Compute the observer gain $L_o$ for the system in OCF:\n   $$ L_o = \\MATRIX{ α_0 - a_0 \\\\ \\vdots \\\\ α_{n-1} - a_{n-1}}. $$\n\n8. The controller gain for the original system is\n   $$L = T L_o.$$\n\n\n#### Method 2: A slightly more efficient approach {-} \n\nIt is possible to avoid the computation of the observability matrix of the system in OCF by\nreplacing steps 4--6 of Method 1 by the following:\n\n4. Compute the matrix\n   $$ W = \\MATRIX{ a_1 & a_2 & \\cdots & a_{n-1} & 1 \\\\\n                   a_2 & \\iddots & \\iddots & 1 & 0 \\\\\n                   \\iddots & \\iddots & \\iddots & \\iddots & \\vdots \\\\\n                  a_{n-1} & 1 & 0 & \\cdots & 0 \\\\\n                  1 & 0 & 0 & \\cdots & 0 \n                 }\n   $$\n\n5. Compute the transformation:\n   $$\\bbox[5pt,border: 1px solid]{\n    T = \\bigl[ W \\mathcal O_{(A,C)} \\bigr]^{-1}\n   }$$\n\nThis method relies on the fact that for a system $(A_o,C_o)$ in OCF, $\\mathcal O_{(A_o,C_o)} = W^{-1}$. For a proof, see Lemma 4.5 of William and Lawrence. \n\n:::{#exm-observer-design}\nConsider the following SSM:\n$$ A = \\MATRIX{3 & 1 \\\\ 1 & 2}, B = \\MATRIX{2 \\\\1} \\text{ and } C = \\MATRIX{ 3 & 2}. $$\nDesign a Luenberger observer (i.e., compute the observer gain $L$) such that the eigenvalues of $A - LC$ are at $-10 \\pm 5j$. \n:::\n\n\n## Output feedback\n\nConsider a SSM \n\\begin{align*}\n\\dot x(t) &= A x(t) + B u(t) \\\\\ny(t) &= C x(t)\n\\end{align*}\n\nIn this section, we will learn how to control such a system when the controller does not have access to the internal state $x(t)$, but can only observe the output $y(t)$. This is called **output feedback**.\n\n![Block diagram for output feedback](figures/svg/SSM2.svg){#fig-block}\n\nThe basic idea of output feedback is to first estimate the state of the system via a Luenberger observer\n$$\n\\dot {\\hat x}(t) = A \\hat x(t) + B u(t) + L (y(t) - C \\hat x(t)),\n\\quad\\text{where }\nL = \\MATRIX{\\ell_0 \\\\ \\vdots \\\\ \\ell_{n-1}}\n$$\nand then use a linear feedback controller that uses the estimated state:\n$$\n  u(t) = - K \\hat x(t), \n\\quad\\text{where }\nK = \\MATRIX{k_0 & \\cdots & k_{n-1}}.\n$$\n\nAs before, we will first consider the system without any reference signal, i.e., $r(t) = 0$. In tihs case, there are\n$2n$ tunable gains $k_0, \\dots, k_{n-1}$ and $\\ell_0, \\dots, \\ell_{n-1}$ and the hope is that we can find these gain to arbitrarily choose the eigenvalues of the closed loop system. \n\nWriting the above equations in state space form, we get\n$$\n\\MATRIX{ \\dot x(t) \\\\ \\dot {\\hat x}(t) } =\n\\MATRIX{ A & -BK \\\\ LC & A - BK - LC } \n\\MATRIX{ x(t) \\\\ \\hat x(t) }.\n$$\nBy using the transformation $T = \\MATRIX{I & 0 \\\\ I & -I}$, we get\n$$\n\\MATRIX{ \\dot x(t) \\\\ \\dot e(t) } =\n\\MATRIX{ A - BK & BK \\\\ 0 & A - LC } \n\\MATRIX{ x(t) \\\\ e(t) }.\n$$\nThus, the characteristic polynomial of the closed loop system is\n$$\n\\DET{ A - BK & -BK \\\\ 0 & A - LC }  = \n\\det(sI - (A - BK)) \\det(sI - (A-LC))\n$$\nwhere we have used the fact that the determiniant of a block diagonal upper triangular matrix is the product of the determinants of the diagonal sub-matrices. \n\nThus, \n$$\n\\{\\text{eigenvalues of closed loop system}\\}\n= \\{\\text{eigenvalues of $(A - BK)$}\\} \\cup \n  \\{\\text{eigenvalues of $(A - LC)$}\\}.\n$$\nThus, we can separately design the controller gain $K$ and the observer gain $L$ by using the methods described earlier. This is called **the separation principle.**\n\nIf we choose observer poles several times faster than controller poles, the controller poles will dominate. Thus, output feedback gives essentially the same performance as (the non-implementable) state feedback. \n\n",
    "supporting": [
      "output-feedback_files"
    ],
    "filters": [],
    "includes": {}
  }
}